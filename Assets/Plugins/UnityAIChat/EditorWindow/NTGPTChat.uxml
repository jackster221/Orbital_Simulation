<ui:UXML xmlns:ui="UnityEngine.UIElements" xmlns:uie="UnityEditor.UIElements" xsi="http://www.w3.org/2001/XMLSchema-instance" engine="UnityEngine.UIElements" editor="UnityEditor.UIElements" noNamespaceSchemaLocation="../../../UIElementsSchema/UIElements.xsd" editor-extension-mode="False">
    <Style src="project://database/Assets/Plugins/UnityAIChat/EditorWindow/NTGPTChat.uss?fileID=7433441132597879392&amp;guid=beba529634065994fba075983bf754ee&amp;type=3#NTGPTChat" />
    <ui:VisualElement name="Background" style="flex-grow: 1; background-color: rgba(0, 0, 0, 0); flex-direction: column; flex-shrink: 0; align-items: center; bottom: auto; flex-wrap: nowrap; flex-basis: auto; align-self: center; justify-content: space-around; padding-left: 15px; padding-right: 15px; padding-top: 15px; padding-bottom: 15px;">
        <ui:VisualElement name="OutputBase" style="flex-grow: 1; background-color: rgba(0, 0, 0, 0); height: auto; flex-shrink: 1; justify-content: space-around; align-self: stretch; align-items: stretch; margin-bottom: 30px;">
            <ui:ScrollView vertical-page-size="-1" vertical-scroller-visibility="Auto" focusable="false" usage-hints="DynamicTransform" touch-scroll-type="Clamped" nested-interaction-kind="Default" name="OutputScrollView" style="align-items: stretch; flex-grow: 1; flex-shrink: 0; position: relative; flex-wrap: nowrap; justify-content: space-around; align-self: stretch; height: auto; -unity-text-align: middle-left; white-space: normal; text-overflow: clip; min-height: auto; -unity-background-scale-mode: stretch-to-fill; bottom: auto; flex-basis: auto; flex-direction: column;">
                <ui:TextField value="Implementation  Scrolling is often carried out on a computer by the CPU (software scrolling) or by a graphics processor. Some systems feature hardware scrolling, where an image may be offset as it is displayed, without any frame buffer manipulation (see also hardware windowing). This was especially common in 8 and 16bit video game consoles. UI paradigms  In a WIMP-style graphical user interface (GUI), user-controlled scrolling is carried out by manipulating a scrollbar with a mouse, or using keyboard shortcuts, often the arrow keys. Scrolling is often supported by text user interfaces and command line interfaces. Older computer terminals changed the entire contents of the display one screenful (&quot;page&quot;) at a time; this paging mode requires fewer resources than scrolling. Scrolling displays often also support page mode. Typically certain keys or key combinations page up or down; on PC-compatible keyboards the page up and page down keys or the space bar are used; earlier computers often used control key combinations.[notes 1] Some computer mice have a scroll wheel, which scrolls the display, often vertically, when rolled; others have scroll balls or tilt wheels which allow both vertical and horizontal scrolling.  Some software supports other ways of scrolling. Adobe Reader has a mode identified by a small hand icon (&quot;hand tool&quot;) on the document, which can then be dragged by clicking on it and moving the mouse as if sliding a large sheet of paper. When this feature is implemented on a touchscreen it is called kinetic scrolling. Touch-screens often use inertial scrolling, in which the scrolling motion of an object continues in a decaying fashion after release of the touch, simulating the appearance of an object with inertia. An early implementation of such behavior was in the &quot;Star7&quot; PDA of Sun Microsystems ca. 1991â€“1992.[2]  Scrolling can be controlled in other software-dependent ways by a PC mouse. Some scroll wheels can be pressed down, functioning like a button. Depending on the software, this allows both horizontal and vertical scrolling by dragging in the direction desired; when the mouse is moved to the original position, scrolling stops. A few scroll wheels can also be tilted, scrolling horizontally in one direction until released. On touchscreen devices, scrolling is a multi-touch gesture, done by swiping a finger on the screen vertically in the direction opposite to where the user wants to scroll to.  If any content is too wide to fit on a display, horizontal scrolling is required to view all of it. In applications such as graphics and spreadsheets there is often more content than can fit either the width or the height of the screen at a comfortable scale, and scrolling in both directions is necessary. Infinite scrolling  In 2006, Aza Raskin developed the infinite scrolling technique, whereby pagination of web pages is eliminated, in favor of continuously loading content as the user scrolls down the page.[3] Raskin later expressed regret at the invention, describing it as &quot;one of the first products designed to not simply help a user, but to deliberately keep them online for as long as possible&quot;.[4] Usability research suggests infinite scrolling can present an accessibility issue.[3] The lack of stopping cues has been described as a pathway to smartphone addiction and social media addiction.[5][6] Text  In languages written horizontally, such as most Western languages, text documents longer than will fit on the screen are often displayed wrapped and sized to fit the screen width, and scrolled vertically to bring desired content into view. It is possible to display lines too long to fit the display without wrapping, scrolling horizontally to view each entire line. However, this requires inconvenient constant line-by-line scrolling, while vertical scrolling is only needed after reading a full screenful.  Software such as word processors and web browsers normally uses word-wrapping to display as many words in a single line as will fit the width of the screen or window or, for text organised in columns, each column. " readonly="true" multiline="true" name="OutputTextField" focusable="true" usage-hints="DynamicTransform" auto-correction="false" style="width: auto; height: auto; white-space: normal; text-overflow: ellipsis; -unity-text-align: middle-left; font-size: 14px; align-self: center; justify-content: space-around; flex-grow: 1; margin-left: 0; margin-right: 0; margin-top: 0; margin-bottom: 0; border-top-left-radius: 0; border-bottom-left-radius: 0; border-top-right-radius: 0; border-bottom-right-radius: 0; flex-direction: column; flex-wrap: nowrap; align-items: center; -unity-background-scale-mode: stretch-to-fill; flex-shrink: 0; overflow: visible; min-height: auto; position: relative;" />
            </ui:ScrollView>
        </ui:VisualElement>
        <ui:VisualElement name="InputBase" style="flex-grow: 1; background-color: rgba(0, 0, 0, 0); height: 103px; flex-shrink: 1; align-self: stretch; justify-content: space-around; margin-bottom: 15px;">
            <ui:Label tabindex="-1" text="Write your prompt" display-tooltip-when-elided="true" name="Label" style="margin-left: 3px; margin-right: 0; margin-top: 0; margin-bottom: 8px; padding-left: 0; padding-right: 0; padding-top: 0; padding-bottom: 0; font-size: 15px;" />
            <ui:ScrollView name="InputScrollView">
                <ui:TextField multiline="true" name="InputTextField" usage-hints="None" picking-mode="Ignore" style="width: auto; flex-grow: 1; justify-content: flex-start; -unity-text-align: upper-left; align-self: stretch; white-space: normal; margin-left: 0; margin-right: 0; margin-top: 0; margin-bottom: 0; padding-left: 0; padding-right: 0; padding-top: 0; padding-bottom: 0; cursor: url(&apos;project://database/Assets/UnityDefaultRuntimeTheme.tss?fileID=-1304905567622442630&amp;guid=3054d8fca35dde845b41b22cbc61b188&amp;type=3#arrow-down@2x&apos;);" />
            </ui:ScrollView>
        </ui:VisualElement>
        <ui:VisualElement name="BottomButtons" style="flex-grow: 1; background-color: rgba(0, 0, 0, 0); flex-direction: row; height: auto; -unity-text-align: middle-left; align-items: stretch; align-self: stretch; justify-content: flex-start; flex-shrink: 0; position: relative; top: auto; bottom: auto; width: auto; padding-left: 0; padding-right: 0; padding-top: 0; padding-bottom: 0;">
            <ui:VisualElement name="Bottom" style="flex-grow: 1; background-color: rgba(0, 0, 0, 0); flex-direction: row;">
                <ui:Button text="Send Prompt" display-tooltip-when-elided="true" name="Send" style="height: auto; flex-direction: row; width: auto; white-space: normal; text-overflow: clip; margin-bottom: 0; margin-top: 0; margin-left: 0; margin-right: 15px; -unity-font-style: normal; -unity-text-align: middle-center; padding-left: 30px; padding-right: 30px; padding-top: 8px; padding-bottom: 8px; border-top-left-radius: 5px; border-bottom-left-radius: 5px; border-top-right-radius: 5px; border-bottom-right-radius: 5px;" />
                <ui:Button text="Clear Text" display-tooltip-when-elided="true" name="Clear" style="height: auto; width: auto; flex-direction: row; margin-top: 0; margin-bottom: 0; margin-right: 0; margin-left: 0; padding-left: 30px; padding-right: 30px; padding-top: 8px; padding-bottom: 8px; white-space: normal; text-overflow: clip; border-top-left-radius: 5px; border-bottom-left-radius: 5px; border-top-right-radius: 5px; border-bottom-right-radius: 5px;" />
            </ui:VisualElement>
            <ui:VisualElement name="Loader" style="flex-grow: 0; background-color: rgba(255, 255, 255, 0); background-image: url(&apos;project://database/Assets/Plugins/UnityAIChat/Textures/loading.png?fileID=2800000&amp;guid=b6d4de376fd14124790dedd81d49323c&amp;type=3#loading&apos;); -unity-slice-left: 0; -unity-slice-top: 0; -unity-slice-right: 0; -unity-slice-bottom: 0; position: relative; width: 35px; height: 35px; justify-content: space-around; align-self: flex-end; align-items: flex-end; rotate: 0;" />
        </ui:VisualElement>
    </ui:VisualElement>
</ui:UXML>
